<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ScriptableApp.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pakcatt</a> &gt; <a href="index.source.html" class="el_package">pakcatt.application.scriptable</a> &gt; <span class="el_source">ScriptableApp.kt</span></div><h1>ScriptableApp.kt</h1><pre class="source lang-java linenums">package pakcatt.application.scriptable

import com.fasterxml.jackson.databind.ObjectMapper
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.springframework.context.annotation.Profile
import org.springframework.stereotype.Component
import pakcatt.application.scriptable.model.Script
import pakcatt.application.shared.RootApp
import pakcatt.application.shared.model.AppRequest
import pakcatt.application.shared.model.AppResponse
import pakcatt.application.shared.model.ResponseType
import java.io.File
import java.io.IOException
import java.util.concurrent.TimeUnit

/**
 * The Scriptable app provides an interface to external software, for example
 * command-line shell or python scripts.
 */

enum class ScriptType {
    CONNECT, REQUEST
}

@Component
@Profile(&quot;production&quot;)
<span class="fc" id="L28">class ScriptableApp(private val scriptableScripts: List&lt;Script&gt;,</span>
                    private val scriptWorkingDir: String,
<span class="fc" id="L30">                    private val scriptTimeout: Long): RootApp() {</span>

<span class="pc" id="L32">    val logger: Logger = LoggerFactory.getLogger(ScriptableApp::class.java)</span>

    /**
     * Find a script that will accept this connection.
     * Only one script can accept and handle a connection.
     */
    override fun decisionOnConnectionRequest(request: AppRequest): AppResponse {
<span class="fc" id="L39">        return handleRequestWithScript(ScriptType.CONNECT, request)</span>
    }

    /**
     * Scripts don't support a prompt. A prompt can be injected into the response
     * by the script, based in any state the script is keeping.
     */
    override fun returnCommandPrompt(): String {
<span class="nc" id="L47">        return &quot;&quot;</span>
    }

    /**
     * Find a script that will handle this message.
     * Only one script can handle the message. The first non-ignored response will be selected.
     */
    override fun handleReceivedMessage(request: AppRequest): AppResponse {
<span class="fc" id="L55">        return handleRequestWithScript(ScriptType.REQUEST, request)</span>
    }

    private fun handleRequestWithScript(scriptType: ScriptType, appRequest: AppRequest): AppResponse {
<span class="fc bfc" id="L59" title="All 2 branches covered.">        for (script in scriptableScripts) {</span>
<span class="fc bfc" id="L60" title="All 2 branches covered.">            val connectScriptPath = when (scriptType) {</span>
<span class="fc" id="L61">                ScriptType.CONNECT -&gt; script.pathConnect</span>
<span class="fc" id="L62">                ScriptType.REQUEST -&gt; script.pathRequest</span>
            }
<span class="fc" id="L64">            val responseString = getOutputFromScript(connectScriptPath, appRequest)</span>
<span class="fc" id="L65">            val scriptResponse = parseAppResponse(responseString)</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">            if (scriptResponse.responseType != ResponseType.IGNORE) {</span>
<span class="fc" id="L67">                return scriptResponse</span>
            }
        }
<span class="fc" id="L70">        return AppResponse.ignore()</span>
    }

    private fun parseAppResponse(responseString: String): AppResponse {
<span class="fc" id="L74">        val chompedString = stringUtils.removeEOLChars(responseString)</span>
<span class="fc" id="L75">        val parameters = chompedString.split(&quot; &quot;)</span>
<span class="pc bpc" id="L76" title="2 of 4 branches missed.">        return if (parameters.isNotEmpty()) {</span>
<span class="fc" id="L77">            val responseTypeString = parameters[0]</span>
<span class="pc bpc" id="L78" title="1 of 4 branches missed.">            return when (responseTypeString) {</span>
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">                &quot;ACK_WITH_TEXT&quot; -&gt; AppResponse.sendText(chompedString.substring(14))</span>
<span class="fc" id="L80">                &quot;ACK_ONLY&quot; -&gt; AppResponse.acknowledgeOnly()</span>
                &quot;IGNORE&quot; -&gt; {
                    // Log any debug text after the IGNORE instruction
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">                    if (chompedString.contains(&quot; &quot;)) {</span>
<span class="nc" id="L84">                        val startLog = chompedString.indexOf(&quot; &quot;) + 1</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">                        logger.debug(&quot;Script logged: {}&quot;, chompedString.substring(startLog, chompedString.length))</span>
                    }
<span class="fc" id="L87">                    AppResponse.ignore()</span>
                }
                else -&gt; {
<span class="nc" id="L90">                    logger.error(&quot;Script returned an invalid response type: $chompedString&quot;)</span>
<span class="nc" id="L91">                    AppResponse.ignore()</span>
                }
            }
        } else {
<span class="nc" id="L95">            logger.error(&quot;Script returned an invalid response: $chompedString&quot;)</span>
<span class="nc" id="L96">            AppResponse.ignore()</span>
        }
    }

    private fun getOutputFromScript(scriptPath: String, appRequest: AppRequest): String {
<span class="fc" id="L101">        val workingDir = File(scriptWorkingDir)</span>
<span class="fc" id="L102">        return try {</span>
<span class="fc" id="L103">            val objectMapper = ObjectMapper()</span>
<span class="fc" id="L104">            val jsonInputArguments = objectMapper.writeValueAsString(appRequest)</span>
<span class="fc" id="L105">            val proc = ProcessBuilder(scriptPath, jsonInputArguments)</span>
<span class="fc" id="L106">                .directory(workingDir)</span>
<span class="fc" id="L107">                .redirectOutput(ProcessBuilder.Redirect.PIPE)</span>
<span class="fc" id="L108">                .redirectError(ProcessBuilder.Redirect.PIPE)</span>
<span class="fc" id="L109">                .start()</span>
<span class="fc" id="L110">            proc.waitFor(scriptTimeout, TimeUnit.SECONDS)</span>
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">            val error = proc.errorStream.bufferedReader().readText()</span>
<span class="pc bpc" id="L112" title="2 of 4 branches missed.">            if (error.isNotEmpty()) {</span>
<span class="nc" id="L113">                logger.error(&quot;While executing script: {} error: {}&quot;, scriptPath, error)</span>
            }
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">            proc.inputStream.bufferedReader().readText()</span>
<span class="nc" id="L116">        } catch(e: IOException) {</span>
<span class="nc" id="L117">            logger.error(&quot;Exception while executing script {} {}&quot;, scriptPath, e.localizedMessage)</span>
<span class="nc" id="L118">            &quot;&quot;</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>