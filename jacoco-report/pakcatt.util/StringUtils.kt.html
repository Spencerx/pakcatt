<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StringUtils.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pakcatt</a> &gt; <a href="index.source.html" class="el_package">pakcatt.util</a> &gt; <span class="el_source">StringUtils.kt</span></div><h1>StringUtils.kt</h1><pre class="source lang-java linenums">package pakcatt.util

import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Component
import java.text.SimpleDateFormat
import java.util.*
import kotlin.math.min

@Component
<span class="fc" id="L10">class StringUtils {</span>

    companion object {
        const val CRLF = &quot;\r\n&quot;
        const val LFCR = &quot;\n\r&quot;
        const val CR = &quot;\r&quot;
        const val LF = &quot;\n&quot;
    }

    @Autowired
<span class="fc" id="L20">    private var defaultEndOfLine: String = LF</span>

<span class="fc" id="L22">    val EOL: String = defaultEndOfLine</span>
<span class="fc" id="L23">    private val dateFormatter = SimpleDateFormat(&quot;dd MMM HH:mm&quot;)</span>

    fun byteToHex(byte: Byte): String {
<span class="fc" id="L26">        return String.format(&quot;%02x&quot;, byte)</span>
    }

    fun intToHex(int: Int): String {
<span class="nc" id="L30">        return String.format(&quot;%02x&quot;, int)</span>
    }

    fun byteArrayToHex(byteArray: ByteArray): String {
<span class="fc" id="L34">        var stringBuilder = StringBuilder()</span>

<span class="fc bfc" id="L36" title="All 2 branches covered.">        for (byte in byteArray) {</span>
<span class="fc" id="L37">            val byteAsHex = byteToHex(byte)</span>
<span class="fc" id="L38">            stringBuilder.append(byteAsHex)</span>
<span class="fc" id="L39">            stringBuilder.append(&quot; &quot;)</span>
        }
<span class="fc" id="L41">        return stringBuilder.toString()</span>
    }

    fun stringToHex(string: String): String {
<span class="fc" id="L45">        var stringBuilder = StringBuilder()</span>
<span class="fc bfc" id="L46" title="All 2 branches covered.">        for (char in string) {</span>
<span class="fc" id="L47">            val hexChar = byteToHex(char.toByte())</span>
<span class="fc" id="L48">            stringBuilder.append(hexChar)</span>
<span class="fc" id="L49">            stringBuilder.append(&quot; &quot;)</span>
        }
<span class="fc" id="L51">        return stringBuilder.toString()</span>
    }

    fun removeWhitespace(string: String): String {
<span class="fc" id="L55">        return string.replace(&quot; &quot;, &quot;&quot;)</span>
    }

    fun convertBytesToString(byteArray: ByteArray): String {
<span class="fc" id="L59">        return String(byteArray, Charsets.US_ASCII)</span>
    }

    fun convertByteToString(byte: Byte): String {
<span class="fc" id="L63">        val byteArrayOfOne = ByteArray(1)</span>
<span class="fc" id="L64">        byteArrayOfOne[0] = byte</span>
<span class="fc" id="L65">        return convertBytesToString(byteArrayOfOne)</span>
    }

    fun convertStringToBytes(string: String): ByteArray {
<span class="fc" id="L69">        return string.toByteArray(Charsets.US_ASCII)</span>
    }

    fun padWithSpaces(string: String, totalLength: Int): String {
<span class="fc" id="L73">        var paddedString = StringBuilder(string)</span>
<span class="fc bfc" id="L74" title="All 4 branches covered.">        for (i in string.length + 1 .. totalLength) {</span>
<span class="fc" id="L75">            paddedString.append(&quot; &quot;)</span>
        }
<span class="fc" id="L77">        return paddedString.toString()</span>
    }

    /**
     * Remove any end-of-line characters from a string
     */
    fun removeEOLChars(input: String): String {
<span class="fc" id="L84">        return removeEOLChars(input, &quot;&quot;)</span>
    }

    fun removeEOLChars(input: String, substitutionString: String): String {
<span class="fc" id="L88">        var returnedString = input.replace(&quot;\r&quot;,substitutionString)</span>
<span class="fc" id="L89">        returnedString = returnedString.replace(&quot;\n&quot;, substitutionString)</span>
<span class="fc" id="L90">        return returnedString</span>
    }

    /**
     * Remove any SSID number and make the callsign uppercase
     */
    fun formatCallsignRemoveSSID(callsign: String): String {
<span class="fc" id="L97">        val callsignOnly = when (callsign.contains(&quot;-&quot;)) {</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">            true -&gt; callsign.split(&quot;-&quot;)[0]</span>
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">            false -&gt; callsign</span>
        }
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">        return callsignOnly.toUpperCase()</span>
    }

    /**
     * Format a callsign, ensuring it has at least
     * the default SSID
     */
    fun formatCallsignEnsureSSID(callsign: String): String {
<span class="fc" id="L109">        return when (callsign.contains(&quot;-&quot;)) {</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">            true -&gt; callsign.toUpperCase()</span>
<span class="pc bpc" id="L111" title="2 of 4 branches missed.">            false -&gt; &quot;$callsign-0&quot;.toUpperCase()</span>
        }
    }

    /**
     * Parse an input array of bytes and fix any End Of Line (EOL)
     * characters, replacing them with a specified EOL sequence.
     */
    fun fixEndOfLineCharacters(inputString: String, newEOLString: String): String {
<span class="fc" id="L120">        var fixedString = inputString</span>

        // Swap CRLF with LF
<span class="fc" id="L123">        fixedString = fixedString.replace(&quot;${CR}${LF}&quot;, LF)</span>
        // Swap LFCR with LF
<span class="fc" id="L125">        fixedString = fixedString.replace(&quot;${LF}${CR}&quot;, LF)</span>
        // Swap CR with LF
<span class="fc" id="L127">        fixedString = fixedString.replace(CR, LF)</span>
        // All EOL sqeuences should be reduced to LF, now swap it with the designated new EOL string
<span class="fc" id="L129">        fixedString = fixedString.replace(LF, newEOLString)</span>

<span class="fc" id="L131">        return fixedString.toString()</span>
    }

    /**
     * Create a string of a fixed size, padding with space
     * on the end of the string if required.
     */
    fun fixedSizeString(inputString: String, fixedSize: Int): String {
<span class="fc" id="L139">        var returnedString = inputString</span>
<span class="pc bpc" id="L140" title="1 of 4 branches missed.">        for (index in returnedString.length..fixedSize) {</span>
<span class="fc" id="L141">            returnedString += &quot; &quot;</span>
        }
<span class="fc" id="L143">        return trimmedString(returnedString, fixedSize)</span>
    }

    fun trimmedString(inputString: String, maxLength: Int): String {
<span class="fc" id="L147">        return inputString.substring(0, min(maxLength, inputString.length))</span>
    }

    fun formattedDate(date: Date): String {
<span class="fc" id="L151">        return dateFormatter.format(date.time)</span>
    }

    fun shortenString(string: String, maxLength: Int, withEllipsis: Boolean): String {
<span class="fc" id="L155">        val length = maxLength.coerceAtMost(string.length)</span>
<span class="pc bpc" id="L156" title="1 of 4 branches missed.">        return if (length &lt; string.length &amp;&amp; withEllipsis) {</span>
<span class="fc" id="L157">            &quot;${string.substring(0 until length)}...&quot;</span>
        } else {
<span class="fc" id="L159">            string.substring(0 until length)</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>