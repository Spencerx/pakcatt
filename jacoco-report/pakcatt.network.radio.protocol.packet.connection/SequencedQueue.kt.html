<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SequencedQueue.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pakcatt</a> &gt; <a href="index.source.html" class="el_package">pakcatt.network.radio.protocol.packet.connection</a> &gt; <span class="el_source">SequencedQueue.kt</span></div><h1>SequencedQueue.kt</h1><pre class="source lang-java linenums">package pakcatt.network.radio.protocol.packet.connection

import pakcatt.network.radio.kiss.model.KissFrame
import java.util.*
import kotlin.math.min

<span class="fc" id="L7">class SequencedQueue(private val framesPerOver: Int,</span>
                     private val maxDeliveryAttempts: Int,
                     private val deliveryRetryTimeSeconds: Int) {

<span class="fc" id="L11">    private val maxSequenceNumberSize = 8</span>
<span class="fc" id="L12">    private var sequencedFramesForDelivery = ArrayList&lt;KissFrame&gt;(maxSequenceNumberSize)</span>

    /* Section 4.2.4 Frame Variables and Sequence Numbers, Beech et all */
    /* The send state variable contains the next sequential number to be assigned to the next transmitted I frame.
     * This variable is updated with the transmission of each I frame.*/
    private var ourNextUnboundedSendSequenceNumber = 0

    /* The nextBoundedSendNumberExpectedByPeer state variable contains the sequence number of the last
     * frame acknowledged by our remote peer [V(A)-1 equals the N(S) of the last acknowledged I frame]. */
    private var nextBoundedSendNumberExpectedByPeer = 0
    private var nextUnboundedFrameIndexExpectedByPeer = 0

    fun reset() {
<span class="fc" id="L25">        sequencedFramesForDelivery = ArrayList&lt;KissFrame&gt;()</span>
<span class="fc" id="L26">        ourNextUnboundedSendSequenceNumber = 0</span>
<span class="fc" id="L27">        nextBoundedSendNumberExpectedByPeer = 0</span>
<span class="fc" id="L28">        nextUnboundedFrameIndexExpectedByPeer = 0</span>
<span class="fc" id="L29">    }</span>

    fun addFrameForSequencedTransmission(newFrame: KissFrame) {
<span class="pc bpc" id="L32" title="1 of 2 branches missed.">        if (newFrame.requiresSendSequenceNumber()) {</span>
<span class="fc" id="L33">            newFrame.setSendSequenceNumber(ourNextBoundedSendSequenceNumber())</span>
<span class="fc" id="L34">            ourNextUnboundedSendSequenceNumber++</span>
        }
<span class="fc" id="L36">        sequencedFramesForDelivery.add(newFrame)</span>
<span class="fc" id="L37">    }</span>

    fun getSequencedFramesForDelivery(): LinkedList&lt;KissFrame&gt; {
<span class="fc" id="L40">        val timeStampNow = Date().time</span>
<span class="fc" id="L41">        val startIndex = nextUnboundedFrameIndexExpectedByPeer</span>
<span class="fc" id="L42">        val endIndex = min((startIndex + framesPerOver - 1), ourNextUnboundedSendSequenceNumber - 1)</span>
<span class="fc" id="L43">        val deliveryRetryTimeMilliseconds = deliveryRetryTimeSeconds * 1000</span>
<span class="fc" id="L44">        var framesForDelivery = LinkedList&lt;KissFrame&gt;()</span>

<span class="pc bpc" id="L46" title="1 of 4 branches missed.">        if (startIndex &gt;= 0 &amp;&amp; endIndex &gt;= 0) {</span>
<span class="pc bpc" id="L47" title="1 of 4 branches missed.">            for (index in startIndex..endIndex) {</span>
<span class="fc" id="L48">                val frameAwaitingDelivery = sequencedFramesForDelivery[index]</span>
                if (frameAwaitingDelivery.deliveryAttempts &lt; maxDeliveryAttempts
<span class="pc bpc" id="L50" title="1 of 4 branches missed.">                    &amp;&amp; frameAwaitingDelivery.lastDeliveryAttemptTimeStamp &lt; timeStampNow - deliveryRetryTimeMilliseconds) {</span>
                    // Attempt to deliver this frame
<span class="fc" id="L52">                    frameAwaitingDelivery.deliveryAttempts++</span>
<span class="fc" id="L53">                    frameAwaitingDelivery.lastDeliveryAttemptTimeStamp = timeStampNow</span>
<span class="fc" id="L54">                    framesForDelivery.add(frameAwaitingDelivery)</span>
                }
            }
        }
<span class="fc" id="L58">        return framesForDelivery</span>
    }

    /**
     * Returns true if the current or next call to getSequencedFramesForDelivery
     * returns the last frames remaining in the delivery queue.
     */
    fun isAtEndOfMessageDelivery(): Boolean {
<span class="fc bfc" id="L66" title="All 2 branches covered.">        return nextUnboundedFrameIndexExpectedByPeer &gt;= ourNextUnboundedSendSequenceNumber - framesPerOver</span>
    }

    // Keep a record of the next send sequence number our remote party expects us to send
    fun handleIncomingAcknowledgementAndIfRepeated(incomingFrame: KissFrame): Boolean {
<span class="fc bfc" id="L71" title="All 2 branches covered.">        return if (nextBoundedSendNumberExpectedByPeer == incomingFrame.receiveSequenceNumber()) {</span>
<span class="fc" id="L72">            true</span>
        } else {
            /*
             * Calculate the difference between this value and the previous received value and
             * use it to adjust the unbounded index that points to the next frame expected
             * to be received by our remote peer.
             */
<span class="fc" id="L79">            val difference = when {</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">                incomingFrame.receiveSequenceNumber() &gt; nextBoundedSendNumberExpectedByPeer -&gt; incomingFrame.receiveSequenceNumber() - nextBoundedSendNumberExpectedByPeer</span>
<span class="fc" id="L81">                else -&gt; incomingFrame.receiveSequenceNumber() + maxSequenceNumberSize - nextBoundedSendNumberExpectedByPeer</span>
            }
<span class="fc" id="L83">            nextUnboundedFrameIndexExpectedByPeer += difference</span>
<span class="fc" id="L84">            nextBoundedSendNumberExpectedByPeer = incomingFrame.receiveSequenceNumber()</span>
<span class="fc" id="L85">            false</span>
        }
    }

    /**
     * Return the next bounded (0 - 7) send sequence number.
     * Converts an unbounded positive integer to a value between
     * 0 and 7.
     */
    private fun ourNextBoundedSendSequenceNumber(): Int {
<span class="fc" id="L95">        return ourNextUnboundedSendSequenceNumber % 8</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>