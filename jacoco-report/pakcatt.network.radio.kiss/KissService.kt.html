<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KissService.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">pakcatt</a> &gt; <a href="index.source.html" class="el_package">pakcatt.network.radio.kiss</a> &gt; <span class="el_source">KissService.kt</span></div><h1>KissService.kt</h1><pre class="source lang-java linenums">package pakcatt.network.radio.kiss

import org.slf4j.LoggerFactory
import org.springframework.scheduling.annotation.Scheduled
import org.springframework.stereotype.Service
import pakcatt.network.radio.kiss.model.ControlField
import pakcatt.network.radio.kiss.model.KissFrame
import pakcatt.network.radio.kiss.model.KissFrameStandard
import pakcatt.network.radio.kiss.queue.DeliveryQueue
import pakcatt.network.radio.protocol.shared.ProtocolService
import pakcatt.network.radio.tnc.TNC
import pakcatt.util.ByteUtils
import pakcatt.util.StringUtils
import javax.annotation.PreDestroy

@Service
<span class="fc" id="L17">class KissService(val tncConnection: TNC,</span>
<span class="fc" id="L18">                  val protocolServices: List&lt;ProtocolService&gt;,</span>
<span class="fc" id="L19">                  val stringUtils: StringUtils,</span>
<span class="fc" id="L20">                  val byteUtils: ByteUtils,</span>
<span class="fc" id="L21">                  val myCall: String,</span>
<span class="fc" id="L22">                  val sendStartupShutdownMessage: Boolean,</span>
<span class="fc" id="L23">                  val startupMessage: String,</span>
<span class="fc" id="L24">                  val shutdownMessage: String) {</span>

<span class="fc" id="L26">    private val logger = LoggerFactory.getLogger(KissService::class.java)</span>
<span class="fc" id="L27">    private var incomingFrame = ByteArray(1024)</span>
<span class="fc" id="L28">    private var incomingFrameIndex = -1</span>

    init {
<span class="fc" id="L31">        tncConnection.setReceiveDataCallback {</span>
<span class="fc" id="L32">            handleNewByte(it)</span>
<span class="fc" id="L33">        }</span>
<span class="fc" id="L34">        tncConnection.connect()</span>
<span class="fc" id="L35">        onStartup()</span>
    }

    @Scheduled(fixedDelay = 500)
    private fun collectAndDeliverFrames() {
<span class="fc" id="L40">        val framesForDelivery = DeliveryQueue()</span>
<span class="fc bfc" id="L41" title="All 2 branches covered.">        for (protocolService in protocolServices) {</span>
<span class="fc" id="L42">            protocolService.queueFramesForDelivery(framesForDelivery)</span>
        }
<span class="fc bfc" id="L44" title="All 2 branches covered.">        for (frame in framesForDelivery.allFrames()) {</span>
<span class="fc" id="L45">            transmitFrame(frame)</span>
        }
<span class="fc" id="L47">    }</span>

    /**
     * This method is called when the PakCatt service is started, and
     * can send a broadcase to announce it's on frequency, if configured.
     */
    private fun onStartup() {
<span class="pc bpc" id="L54" title="1 of 2 branches missed.">        if (sendStartupShutdownMessage) {</span>
<span class="fc" id="L55">            logger.debug(&quot;Sending on frequency broadcast&quot;)</span>
<span class="fc" id="L56">            val frame = newBroadcastFrame(startupMessage)</span>
<span class="fc" id="L57">            transmitFrame(frame)</span>
        }
<span class="fc" id="L59">    }</span>

    /**
     * This method is called when the PakCatt service is shutdown, and
     * can send a QRT broadcast if configured
     */
    @PreDestroy
    private fun onShutdown() {
<span class="pc bpc" id="L67" title="1 of 2 branches missed.">        if (sendStartupShutdownMessage) {</span>
<span class="fc" id="L68">            logger.debug(&quot;Sending QRT broadcast&quot;)</span>
<span class="fc" id="L69">            val frame = newBroadcastFrame(shutdownMessage)</span>
<span class="fc" id="L70">            transmitFrame(frame)</span>
        }
<span class="fc" id="L72">    }</span>

    private fun newBroadcastFrame(message: String): KissFrame {
<span class="fc" id="L75">        val frame = KissFrameStandard()</span>
<span class="fc" id="L76">        frame.setControlField(ControlField.U_UNNUMBERED_INFORMATION)</span>
<span class="fc" id="L77">        frame.setSourceCallsign(myCall)</span>
<span class="fc" id="L78">        frame.setDestCallsign(&quot;CQ&quot;)</span>
<span class="fc" id="L79">        frame.setPayloadMessage(message)</span>
<span class="fc" id="L80">        return frame</span>
    }

    private fun transmitFrame(frame: KissFrame) {
<span class="fc" id="L84">        tncConnection.sendData(frame.packetData())</span>
<span class="fc" id="L85">        tncConnection.sendData(KissFrame.FRAME_END)</span>
<span class="fc" id="L86">        logger.trace(&quot;Sent bytes:\t\t {}&quot;, stringUtils.byteArrayToHex(frame.packetData()))</span>
<span class="fc" id="L87">        logger.debug(&quot;Sent frame:\t\t {}&quot;, stringUtils.removeEOLChars(frame.toString(), &quot; &quot;))</span>
<span class="fc" id="L88">    }</span>

    private fun handleNewByte(newByte: Byte) {
<span class="fc bfc" id="L91" title="All 2 branches covered.">        if (KissFrame.FRAME_END == newByte.toInt()) {</span>
<span class="fc" id="L92">            logger.trace(&quot;Received boundary of KISS frame after ${incomingFrameIndex + 1} bytes&quot;)</span>

<span class="fc bfc" id="L94" title="All 2 branches covered.">            if (incomingFrameIndex &gt;= 0) {</span>
                // Make a copy of the new frame
<span class="fc" id="L96">                val newFrame = incomingFrame.copyOfRange(0, incomingFrameIndex + 1)</span>

                // Reset the current frame memory
<span class="fc" id="L99">                incomingFrameIndex = -1</span>
<span class="fc" id="L100">                incomingFrame = ByteArray(1024)</span>

                // Handle the new frame
<span class="fc" id="L103">                handleNewFrame(newFrame)</span>
            }
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">        } else if (incomingFrameIndex &gt;= incomingFrame.size) {</span>
<span class="nc" id="L106">            incomingFrameIndex = -1</span>
        } else {
            // Add the next byte to the current incoming frame.
<span class="fc" id="L109">            incomingFrameIndex++</span>
<span class="fc" id="L110">            incomingFrame[incomingFrameIndex] = newByte</span>
        }
<span class="fc" id="L112">    }</span>

    private fun handleNewFrame(frame: ByteArray) {
<span class="fc" id="L115">        logger.debug(&quot;Received bytes:\t {}&quot;, stringUtils.byteArrayToHex(frame))</span>
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">        if (frame.size &gt;= KissFrame.SIZE_MIN) {</span>
<span class="fc" id="L117">            val kissFrame = KissFrameStandard()</span>
<span class="fc" id="L118">            kissFrame.populateFromFrameData(frame)</span>
<span class="fc" id="L119">            logger.trace(&quot;Recoded bytes:\t {}&quot;, stringUtils.byteArrayToHex(kissFrame.packetData()))</span>
<span class="fc" id="L120">            logger.debug(&quot;Received frame:\t {}&quot;, stringUtils.removeEOLChars(kissFrame.toString(), &quot; &quot;))</span>
<span class="fc" id="L121">            logger.trace(&quot;Decoded data:\t {}&quot;, kissFrame.payloadDataString())</span>
<span class="fc" id="L122">            handFrameToProtocolServices(kissFrame)</span>
        } else {
<span class="nc" id="L124">            logger.error(&quot;KISS frame was too small to decode: ${frame.size} bytes&quot;)</span>
        }
<span class="fc" id="L126">    }</span>

    private fun handFrameToProtocolServices(frame: KissFrame) {
<span class="fc bfc" id="L129" title="All 2 branches covered.">        for (protocolService in protocolServices) {</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">            if (protocolService.supportedProtocol(byteUtils.byteToInt(frame.protocolID()), frame.controlField())) {</span>
<span class="fc" id="L131">                protocolService.handleFrame(frame)</span>
            }
        }
<span class="fc" id="L134">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>